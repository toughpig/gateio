# è‡ªåŠ¨åŒ–äº¤æ˜“ç³»ç»Ÿå®ç°ç¤ºä¾‹

## æ¦‚è¿°

åŸºäºè®¾è®¡æŒ‡å—ï¼Œè¿™é‡Œæä¾›ä¸€ä¸ªç®€åŒ–ä½†å¯å®é™…è¿è¡Œçš„è‡ªåŠ¨åŒ–äº¤æ˜“ç³»ç»Ÿç¤ºä¾‹ã€‚æ­¤ç¤ºä¾‹åŒ…å«æ ¸å¿ƒåŠŸèƒ½ï¼Œé€‚åˆä½œä¸ºèµ·ç‚¹è¿›è¡Œå¼€å‘å’Œæ‰©å±•ã€‚

## ğŸ“ é¡¹ç›®ç»“æ„

å»ºè®®åœ¨å½“å‰é¡¹ç›®åŸºç¡€ä¸Šæ·»åŠ ä»¥ä¸‹æ–‡ä»¶ç»“æ„ï¼š

```
automated_trading/
â”œâ”€â”€ __init__.py
â”œâ”€â”€ config/
â”‚   â”œâ”€â”€ __init__.py
â”‚   â””â”€â”€ trading_config.yaml
â”œâ”€â”€ core/
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ data_collector.py
â”‚   â”œâ”€â”€ strategy_engine.py
â”‚   â”œâ”€â”€ trade_executor.py
â”‚   â”œâ”€â”€ risk_manager.py
â”‚   â””â”€â”€ logger.py
â”œâ”€â”€ strategies/
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ base_strategy.py
â”‚   â”œâ”€â”€ grid_strategy.py
â”‚   â””â”€â”€ rsi_strategy.py
â”œâ”€â”€ utils/
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ indicators.py
â”‚   â””â”€â”€ helpers.py
â”œâ”€â”€ logs/
â”œâ”€â”€ data/
â”œâ”€â”€ main.py
â””â”€â”€ requirements.txt
```

## ğŸ“¦ ä¾èµ–åŒ…

```txt
# requirements.txt
gate-api>=6.0.0
python-dotenv>=0.19.0
pandas>=1.3.0
numpy>=1.21.0
pyyaml>=6.0
schedule>=1.1.0
asyncio
websockets>=10.0
```

## âš™ï¸ é…ç½®æ–‡ä»¶

```yaml
# config/trading_config.yaml
system:
  log_level: INFO
  data_update_interval: 10  # ç§’
  max_concurrent_orders: 5
  enable_trading: false  # æµ‹è¯•æ¨¡å¼ï¼Œè®¾ä¸ºfalseæ—¶ä¸ä¼šå®é™…äº¤æ˜“
  
api:
  base_url: "https://api.gateio.ws/api/v4"
  timeout: 30
  
risk_management:
  max_position_ratio: 0.05  # æœ€å¤§ä»“ä½æ¯”ä¾‹5%
  max_daily_loss: 0.02     # æœ€å¤§æ—¥æŸå¤±2%
  stop_loss_ratio: 0.03    # æ­¢æŸ3%
  take_profit_ratio: 0.06  # æ­¢ç›ˆ6%
  min_order_amount: 10     # æœ€å°è®¢å•é‡‘é¢(USDT)
  
trading_pairs:
  - BTC_USDT
  - ETH_USDT
  
strategies:
  rsi_strategy:
    enabled: true
    rsi_period: 14
    oversold: 30
    overbought: 70
    base_amount: 20  # åŸºç¡€äº¤æ˜“é‡‘é¢(USDT)
    
  grid_strategy:
    enabled: false
    grid_size: 0.01
    max_grids: 5
    base_amount: 50
```

## ğŸ”§ æ ¸å¿ƒæ¨¡å—å®ç°

### 1. æ•°æ®æ”¶é›†å™¨ (core/data_collector.py)

```python
#!/usr/bin/env python
# -*- coding: utf-8 -*-

import time
import logging
from dataclasses import dataclass
from typing import Dict, List, Optional
import gate_api
from gate_api.exceptions import ApiException, GateApiException

@dataclass
class MarketData:
    """å¸‚åœºæ•°æ®ç»“æ„"""
    timestamp: float
    currency_pair: str
    current_price: float
    orderbook: Dict
    ticker: Dict
    klines: List
    volume_24h: float

@dataclass
class AccountData:
    """è´¦æˆ·æ•°æ®ç»“æ„"""
    timestamp: float
    balances: Dict[str, Dict]
    total_value_usdt: float
    available_balance: Dict[str, float]

class DataCollector:
    """æ•°æ®æ”¶é›†å™¨"""
    
    def __init__(self, api_client):
        self.api_client = api_client
        self.logger = logging.getLogger(__name__)
        self.spot_api = gate_api.SpotApi(api_client)
        
    def get_market_data(self, currency_pair: str) -> Optional[MarketData]:
        """è·å–å¸‚åœºæ•°æ®"""
        try:
            # è·å–è¡Œæƒ…æ•°æ®
            ticker = self.spot_api.list_tickers(currency_pair=currency_pair)[0]
            
            # è·å–è®¢å•ç°¿
            orderbook = self.spot_api.list_order_book(currency_pair, limit=10)
            
            # è·å–Kçº¿æ•°æ®
            klines = self.spot_api.list_candlesticks(
                currency_pair=currency_pair,
                interval='5m',
                limit=50
            )
            
            return MarketData(
                timestamp=time.time(),
                currency_pair=currency_pair,
                current_price=float(ticker.last),
                orderbook={
                    'asks': orderbook.asks[:5],
                    'bids': orderbook.bids[:5]
                },
                ticker=ticker.__dict__,
                klines=klines,
                volume_24h=float(ticker.base_volume)
            )
            
        except (GateApiException, ApiException) as e:
            self.logger.error(f"Failed to get market data for {currency_pair}: {e}")
            return None
            
    def get_account_data(self) -> Optional[AccountData]:
        """è·å–è´¦æˆ·æ•°æ®"""
        try:
            balances = self.spot_api.list_spot_accounts()
            
            balance_dict = {}
            available_balance = {}
            total_value = 0.0
            
            for balance in balances:
                if float(balance.available) > 0 or float(balance.locked) > 0:
                    balance_dict[balance.currency] = {
                        'available': float(balance.available),
                        'locked': float(balance.locked),
                        'total': float(balance.available) + float(balance.locked)
                    }
                    available_balance[balance.currency] = float(balance.available)
                    
                    # ç®€å•ä¼°ç®—æ€»ä»·å€¼ï¼ˆè¿™é‡Œåªè®¡ç®—USDTå’Œä¸»æµå¸ç§ï¼‰
                    if balance.currency == 'USDT':
                        total_value += balance_dict[balance.currency]['total']
                    elif balance.currency in ['BTC', 'ETH']:
                        # è¿™é‡Œéœ€è¦è·å–å½“å‰ä»·æ ¼æ¥è®¡ç®—ï¼Œç®€åŒ–å¤„ç†
                        pass
                        
            return AccountData(
                timestamp=time.time(),
                balances=balance_dict,
                total_value_usdt=total_value,
                available_balance=available_balance
            )
            
        except (GateApiException, ApiException) as e:
            self.logger.error(f"Failed to get account data: {e}")
            return None
```

### 2. ç­–ç•¥åŸºç±» (strategies/base_strategy.py)

```python
#!/usr/bin/env python
# -*- coding: utf-8 -*-

from abc import ABC, abstractmethod
from dataclasses import dataclass
import time

@dataclass
class TradingSignal:
    """äº¤æ˜“ä¿¡å·"""
    action: str  # 'BUY', 'SELL', 'HOLD'
    currency_pair: str
    price: float
    amount: float
    signal_strength: float = 0.0
    reason: str = ""
    timestamp: float = None
    
    def __post_init__(self):
        if self.timestamp is None:
            self.timestamp = time.time()

class BaseStrategy(ABC):
    """äº¤æ˜“ç­–ç•¥åŸºç±»"""
    
    def __init__(self, config: dict):
        self.config = config
        self.name = self.__class__.__name__
        
    @abstractmethod
    def analyze(self, market_data, account_data) -> TradingSignal:
        """åˆ†æå¸‚åœºæ•°æ®ï¼Œç”Ÿæˆäº¤æ˜“ä¿¡å·"""
        pass
        
    def get_strategy_name(self) -> str:
        """è·å–ç­–ç•¥åç§°"""
        return self.name
        
    def calculate_amount(self, price: float, base_amount: float) -> float:
        """è®¡ç®—äº¤æ˜“æ•°é‡"""
        return base_amount / price
```

### 3. RSIç­–ç•¥å®ç° (strategies/rsi_strategy.py)

```python
#!/usr/bin/env python
# -*- coding: utf-8 -*-

import pandas as pd
import numpy as np
from .base_strategy import BaseStrategy, TradingSignal

class RSIStrategy(BaseStrategy):
    """RSIæŒ‡æ ‡ç­–ç•¥"""
    
    def __init__(self, config: dict):
        super().__init__(config)
        self.rsi_period = config.get('rsi_period', 14)
        self.oversold_threshold = config.get('oversold', 30)
        self.overbought_threshold = config.get('overbought', 70)
        self.base_amount = config.get('base_amount', 20)
        
    def calculate_rsi(self, prices: list) -> float:
        """è®¡ç®—RSIæŒ‡æ ‡"""
        if len(prices) < self.rsi_period + 1:
            return 50.0  # æ•°æ®ä¸è¶³æ—¶è¿”å›ä¸­æ€§å€¼
            
        df = pd.DataFrame({'price': prices})
        delta = df['price'].diff()
        
        gain = (delta.where(delta > 0, 0)).rolling(window=self.rsi_period).mean()
        loss = (-delta.where(delta < 0, 0)).rolling(window=self.rsi_period).mean()
        
        rs = gain / loss
        rsi = 100 - (100 / (1 + rs))
        
        return float(rsi.iloc[-1]) if not pd.isna(rsi.iloc[-1]) else 50.0
        
    def analyze(self, market_data, account_data) -> TradingSignal:
        """åˆ†æå¸‚åœºæ•°æ®ï¼Œç”Ÿæˆäº¤æ˜“ä¿¡å·"""
        # è·å–ä»·æ ¼æ•°æ®ï¼ˆæ”¶ç›˜ä»·ï¼‰
        prices = [float(kline[4]) for kline in market_data.klines]
        
        if len(prices) < self.rsi_period:
            return TradingSignal(
                action='HOLD',
                currency_pair=market_data.currency_pair,
                price=market_data.current_price,
                amount=0,
                reason="Insufficient data for RSI calculation"
            )
            
        rsi = self.calculate_rsi(prices)
        current_price = market_data.current_price
        
        # æ£€æŸ¥è´¦æˆ·ä½™é¢
        base_currency = market_data.currency_pair.split('_')[1]  # USDT
        quote_currency = market_data.currency_pair.split('_')[0]  # BTC/ETH
        
        available_base = account_data.available_balance.get(base_currency, 0)
        available_quote = account_data.available_balance.get(quote_currency, 0)
        
        if rsi < self.oversold_threshold:
            # è¶…å–ï¼Œç”Ÿæˆä¹°å…¥ä¿¡å·
            if available_base >= self.base_amount:
                amount = self.calculate_amount(current_price, self.base_amount)
                return TradingSignal(
                    action='BUY',
                    currency_pair=market_data.currency_pair,
                    price=current_price * 0.999,  # ç¨å¾®ä½äºå¸‚ä»·
                    amount=amount,
                    signal_strength=(self.oversold_threshold - rsi) / self.oversold_threshold,
                    reason=f"RSI oversold: {rsi:.2f}"
                )
                
        elif rsi > self.overbought_threshold:
            # è¶…ä¹°ï¼Œç”Ÿæˆå–å‡ºä¿¡å·
            min_sell_amount = self.base_amount / current_price
            if available_quote >= min_sell_amount:
                amount = min(available_quote * 0.1, min_sell_amount * 2)  # å–å‡º10%æˆ–å›ºå®šé‡‘é¢
                return TradingSignal(
                    action='SELL',
                    currency_pair=market_data.currency_pair,
                    price=current_price * 1.001,  # ç¨å¾®é«˜äºå¸‚ä»·
                    amount=amount,
                    signal_strength=(rsi - self.overbought_threshold) / (100 - self.overbought_threshold),
                    reason=f"RSI overbought: {rsi:.2f}"
                )
                
        return TradingSignal(
            action='HOLD',
            currency_pair=market_data.currency_pair,
            price=current_price,
            amount=0,
            reason=f"RSI neutral: {rsi:.2f}"
        )
```

### 4. é£é™©ç®¡ç†å™¨ (core/risk_manager.py)

```python
#!/usr/bin/env python
# -*- coding: utf-8 -*-

import logging
from typing import Dict, Any
from strategies.base_strategy import TradingSignal

class RiskManager:
    """é£é™©ç®¡ç†å™¨"""
    
    def __init__(self, config: Dict[str, Any]):
        self.config = config
        self.logger = logging.getLogger(__name__)
        
        # é£é™©å‚æ•°
        self.max_position_ratio = config.get('max_position_ratio', 0.1)
        self.max_daily_loss = config.get('max_daily_loss', 0.05)
        self.min_order_amount = config.get('min_order_amount', 10)
        
        # è·Ÿè¸ªæ•°æ®
        self.daily_pnl = 0.0
        self.positions = {}
        
    def check_signal(self, signal: TradingSignal, account_data, market_data) -> bool:
        """æ£€æŸ¥äº¤æ˜“ä¿¡å·æ˜¯å¦ç¬¦åˆé£é™©è¦æ±‚"""
        checks = [
            self.check_daily_loss_limit(),
            self.check_minimum_amount(signal, market_data),
            self.check_balance_sufficient(signal, account_data),
            self.check_position_size(signal, account_data),
            self.check_price_deviation(signal, market_data)
        ]
        
        for i, check in enumerate(checks):
            if not check:
                self.logger.warning(f"Risk check {i+1} failed for signal: {signal}")
                return False
                
        return True
        
    def check_daily_loss_limit(self) -> bool:
        """æ£€æŸ¥æ—¥æŸå¤±é™åˆ¶"""
        if abs(self.daily_pnl) > self.max_daily_loss:
            self.logger.warning(f"Daily loss limit exceeded: {self.daily_pnl}")
            return False
        return True
        
    def check_minimum_amount(self, signal: TradingSignal, market_data) -> bool:
        """æ£€æŸ¥æœ€å°äº¤æ˜“é‡‘é¢"""
        order_value = signal.amount * signal.price
        if order_value < self.min_order_amount:
            self.logger.warning(f"Order amount too small: {order_value}")
            return False
        return True
        
    def check_balance_sufficient(self, signal: TradingSignal, account_data) -> bool:
        """æ£€æŸ¥ä½™é¢æ˜¯å¦å……è¶³"""
        if signal.action == 'BUY':
            base_currency = signal.currency_pair.split('_')[1]
            required_amount = signal.amount * signal.price
            available = account_data.available_balance.get(base_currency, 0)
            
            if available < required_amount:
                self.logger.warning(f"Insufficient {base_currency} balance: {available} < {required_amount}")
                return False
                
        elif signal.action == 'SELL':
            quote_currency = signal.currency_pair.split('_')[0]
            available = account_data.available_balance.get(quote_currency, 0)
            
            if available < signal.amount:
                self.logger.warning(f"Insufficient {quote_currency} balance: {available} < {signal.amount}")
                return False
                
        return True
        
    def check_position_size(self, signal: TradingSignal, account_data) -> bool:
        """æ£€æŸ¥ä»“ä½å¤§å°"""
        if signal.action == 'BUY':
            order_value = signal.amount * signal.price
            max_allowed = account_data.total_value_usdt * self.max_position_ratio
            
            if order_value > max_allowed:
                self.logger.warning(f"Position size too large: {order_value} > {max_allowed}")
                return False
                
        return True
        
    def check_price_deviation(self, signal: TradingSignal, market_data) -> bool:
        """æ£€æŸ¥ä»·æ ¼åç¦»åº¦"""
        current_price = market_data.current_price
        price_deviation = abs(signal.price - current_price) / current_price
        
        max_deviation = 0.02  # æœ€å¤§2%åç¦»
        if price_deviation > max_deviation:
            self.logger.warning(f"Price deviation too large: {price_deviation:.3f}")
            return False
            
        return True
        
    def update_pnl(self, pnl: float):
        """æ›´æ–°æŸç›Š"""
        self.daily_pnl += pnl
```

### 5. äº¤æ˜“æ‰§è¡Œå™¨ (core/trade_executor.py)

```python
#!/usr/bin/env python
# -*- coding: utf-8 -*-

import time
import logging
from typing import Dict, List, Optional
import gate_api
from gate_api.exceptions import ApiException, GateApiException
from strategies.base_strategy import TradingSignal

class TradeExecutor:
    """äº¤æ˜“æ‰§è¡Œå™¨"""
    
    def __init__(self, api_client, enable_trading: bool = False):
        self.api_client = api_client
        self.enable_trading = enable_trading
        self.logger = logging.getLogger(__name__)
        self.spot_api = gate_api.SpotApi(api_client)
        
        self.active_orders: Dict[str, Dict] = {}
        self.order_history: List[Dict] = []
        
    def execute_signal(self, signal: TradingSignal) -> bool:
        """æ‰§è¡Œäº¤æ˜“ä¿¡å·"""
        if signal.action == 'HOLD':
            return True
            
        if not self.enable_trading:
            self.logger.info(f"[SIMULATION] Would execute: {signal.action} {signal.amount:.6f} {signal.currency_pair} @ {signal.price:.6f}")
            return True
            
        try:
            if signal.action == 'BUY':
                return self._place_buy_order(signal)
            elif signal.action == 'SELL':
                return self._place_sell_order(signal)
        except Exception as e:
            self.logger.error(f"Failed to execute signal: {e}")
            return False
            
        return False
        
    def _place_buy_order(self, signal: TradingSignal) -> bool:
        """ä¸‹ä¹°å•"""
        try:
            order = gate_api.Order(
                currency_pair=signal.currency_pair,
                side="buy",
                amount=f"{signal.amount:.8f}",
                price=f"{signal.price:.6f}",
                type="limit",
                time_in_force="gtc"
            )
            
            result = self.spot_api.create_order(order)
            
            self.active_orders[result.id] = {
                'order': result,
                'signal': signal,
                'timestamp': time.time()
            }
            
            self.logger.info(f"Buy order placed: {result.id} - {signal.amount:.6f} {signal.currency_pair} @ {signal.price:.6f}")
            return True
            
        except (GateApiException, ApiException) as e:
            self.logger.error(f"Failed to place buy order: {e}")
            return False
            
    def _place_sell_order(self, signal: TradingSignal) -> bool:
        """ä¸‹å–å•"""
        try:
            order = gate_api.Order(
                currency_pair=signal.currency_pair,
                side="sell",
                amount=f"{signal.amount:.8f}",
                price=f"{signal.price:.6f}",
                type="limit",
                time_in_force="gtc"
            )
            
            result = self.spot_api.create_order(order)
            
            self.active_orders[result.id] = {
                'order': result,
                'signal': signal,
                'timestamp': time.time()
            }
            
            self.logger.info(f"Sell order placed: {result.id} - {signal.amount:.6f} {signal.currency_pair} @ {signal.price:.6f}")
            return True
            
        except (GateApiException, ApiException) as e:
            self.logger.error(f"Failed to place sell order: {e}")
            return False
            
    def check_orders(self):
        """æ£€æŸ¥è®¢å•çŠ¶æ€"""
        for order_id in list(self.active_orders.keys()):
            try:
                order_info = self.active_orders[order_id]
                order = self.spot_api.get_order(order_id, order_info['signal'].currency_pair)
                
                if order.status == 'closed':
                    self._handle_order_filled(order_id, order)
                elif order.status == 'cancelled':
                    self._handle_order_cancelled(order_id, order)
                    
            except Exception as e:
                self.logger.error(f"Failed to check order {order_id}: {e}")
                
    def _handle_order_filled(self, order_id: str, order):
        """å¤„ç†è®¢å•æˆäº¤"""
        order_info = self.active_orders.pop(order_id)
        
        self.order_history.append({
            'order': order,
            'signal': order_info['signal'],
            'filled_time': time.time(),
            'status': 'filled'
        })
        
        self.logger.info(f"Order {order_id} filled: {order.side} {order.amount} {order.currency_pair} @ {order.avg_deal_price}")
        
    def _handle_order_cancelled(self, order_id: str, order):
        """å¤„ç†è®¢å•å–æ¶ˆ"""
        order_info = self.active_orders.pop(order_id)
        
        self.order_history.append({
            'order': order,
            'signal': order_info['signal'],
            'cancelled_time': time.time(),
            'status': 'cancelled'
        })
        
        self.logger.info(f"Order {order_id} cancelled")
        
    def cancel_old_orders(self, max_age_seconds: int = 3600):
        """å–æ¶ˆè¿‡æœŸè®¢å•"""
        current_time = time.time()
        
        for order_id, order_info in list(self.active_orders.items()):
            if current_time - order_info['timestamp'] > max_age_seconds:
                try:
                    self.spot_api.cancel_order(order_id, order_info['signal'].currency_pair)
                    self.logger.info(f"Cancelled old order: {order_id}")
                except Exception as e:
                    self.logger.error(f"Failed to cancel order {order_id}: {e}")
                    
    def get_active_orders_count(self) -> int:
        """è·å–æ´»è·ƒè®¢å•æ•°é‡"""
        return len(self.active_orders)
```

### 6. ä¸»ç¨‹åº (main.py)

```python
#!/usr/bin/env python
# -*- coding: utf-8 -*-

import os
import sys
import time
import yaml
import logging
from pathlib import Path
from dotenv import load_dotenv
import gate_api

# æ·»åŠ é¡¹ç›®ç›®å½•åˆ°Pythonè·¯å¾„
sys.path.append(str(Path(__file__).parent))

from core.data_collector import DataCollector
from core.risk_manager import RiskManager
from core.trade_executor import TradeExecutor
from strategies.rsi_strategy import RSIStrategy

class AutoTradingSystem:
    """è‡ªåŠ¨åŒ–äº¤æ˜“ç³»ç»Ÿ"""
    
    def __init__(self, config_file: str):
        self.config = self._load_config(config_file)
        self.running = False
        self._setup_logging()
        self._setup_components()
        
    def _load_config(self, config_file: str) -> dict:
        """åŠ è½½é…ç½®æ–‡ä»¶"""
        with open(config_file, 'r', encoding='utf-8') as f:
            return yaml.safe_load(f)
            
    def _setup_logging(self):
        """è®¾ç½®æ—¥å¿—"""
        log_level = getattr(logging, self.config['system']['log_level'])
        logging.basicConfig(
            level=log_level,
            format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
            handlers=[
                logging.FileHandler('logs/trading.log'),
                logging.StreamHandler()
            ]
        )
        self.logger = logging.getLogger(__name__)
        
    def _setup_components(self):
        """åˆå§‹åŒ–ç»„ä»¶"""
        # åˆ›å»ºAPIå®¢æˆ·ç«¯
        load_dotenv()
        configuration = gate_api.Configuration(host=self.config['api']['base_url'])
        configuration.key = os.getenv("GATEIO_API_KEY")
        configuration.secret = os.getenv("GATEIO_API_SECRET")
        api_client = gate_api.ApiClient(configuration)
        
        # åˆå§‹åŒ–ç»„ä»¶
        self.data_collector = DataCollector(api_client)
        self.risk_manager = RiskManager(self.config['risk_management'])
        self.trade_executor = TradeExecutor(
            api_client, 
            enable_trading=self.config['system']['enable_trading']
        )
        
        # åˆå§‹åŒ–ç­–ç•¥
        self.strategies = []
        if self.config['strategies']['rsi_strategy']['enabled']:
            self.strategies.append(RSIStrategy(self.config['strategies']['rsi_strategy']))
            
    def run(self):
        """è¿è¡Œä¸»å¾ªç¯"""
        self.running = True
        self.logger.info("Auto trading system started")
        
        if not self.config['system']['enable_trading']:
            self.logger.warning("Trading is DISABLED - running in simulation mode")
            
        try:
            iteration = 0
            while self.running:
                iteration += 1
                self.logger.info(f"=== Iteration {iteration} ===")
                
                # è·å–è´¦æˆ·æ•°æ®
                account_data = self.data_collector.get_account_data()
                if not account_data:
                    self.logger.error("Failed to get account data")
                    time.sleep(self.config['system']['data_update_interval'])
                    continue
                    
                self.logger.info(f"Account USDT balance: {account_data.total_value_usdt:.2f}")
                
                # å¤„ç†æ¯ä¸ªäº¤æ˜“å¯¹
                for currency_pair in self.config['trading_pairs']:
                    self.logger.info(f"Processing {currency_pair}")
                    
                    # è·å–å¸‚åœºæ•°æ®
                    market_data = self.data_collector.get_market_data(currency_pair)
                    if not market_data:
                        self.logger.error(f"Failed to get market data for {currency_pair}")
                        continue
                        
                    self.logger.info(f"{currency_pair} price: {market_data.current_price}")
                    
                    # æ‰§è¡Œç­–ç•¥åˆ†æ
                    for strategy in self.strategies:
                        signal = strategy.analyze(market_data, account_data)
                        
                        self.logger.info(f"{strategy.get_strategy_name()}: {signal.action} - {signal.reason}")
                        
                        # æ£€æŸ¥é£é™©å’Œæ‰§è¡Œäº¤æ˜“
                        if signal.action != 'HOLD':
                            if self.risk_manager.check_signal(signal, account_data, market_data):
                                success = self.trade_executor.execute_signal(signal)
                                if success:
                                    self.logger.info(f"Signal executed successfully")
                                else:
                                    self.logger.error(f"Failed to execute signal")
                            else:
                                self.logger.warning(f"Signal rejected by risk manager")
                                
                # æ£€æŸ¥è®¢å•çŠ¶æ€
                self.trade_executor.check_orders()
                
                # å–æ¶ˆè¿‡æœŸè®¢å•ï¼ˆæ¯10æ¬¡å¾ªç¯æ‰§è¡Œä¸€æ¬¡ï¼‰
                if iteration % 10 == 0:
                    self.trade_executor.cancel_old_orders()
                    
                # æ˜¾ç¤ºçŠ¶æ€
                active_orders = self.trade_executor.get_active_orders_count()
                self.logger.info(f"Active orders: {active_orders}")
                
                # ç­‰å¾…ä¸‹ä¸€è½®
                self.logger.info(f"Sleeping for {self.config['system']['data_update_interval']} seconds...")
                time.sleep(self.config['system']['data_update_interval'])
                
        except KeyboardInterrupt:
            self.logger.info("Trading system stopped by user")
        except Exception as e:
            self.logger.error(f"Trading system error: {e}", exc_info=True)
        finally:
            self._cleanup()
            
    def stop(self):
        """åœæ­¢ç³»ç»Ÿ"""
        self.running = False
        
    def _cleanup(self):
        """æ¸…ç†èµ„æº"""
        self.logger.info("Cleaning up...")
        if self.config['system']['enable_trading']:
            # åœ¨å®é™…äº¤æ˜“æ¨¡å¼ä¸‹ï¼Œå¯ä»¥é€‰æ‹©å–æ¶ˆæ‰€æœ‰æœªå®Œæˆè®¢å•
            # self.trade_executor.cancel_all_orders()
            pass
        self.logger.info("Auto trading system stopped")

if __name__ == "__main__":
    # ç¡®ä¿å¿…è¦çš„ç›®å½•å­˜åœ¨
    Path("logs").mkdir(exist_ok=True)
    Path("data").mkdir(exist_ok=True)
    
    # è¿è¡Œç³»ç»Ÿ
    system = AutoTradingSystem("config/trading_config.yaml")
    try:
        system.run()
    except Exception as e:
        print(f"Failed to start trading system: {e}")
```

## ğŸš€ ä½¿ç”¨æŒ‡å—

### 1. ç¯å¢ƒå‡†å¤‡

```bash
# åˆ›å»ºè™šæ‹Ÿç¯å¢ƒ
python -m venv trading_env
source trading_env/bin/activate  # Linux/Mac
# trading_env\Scripts\activate  # Windows

# å®‰è£…ä¾èµ–
pip install -r requirements.txt

# åˆ›å»ºå¿…è¦ç›®å½•
mkdir -p automated_trading/config
mkdir -p automated_trading/logs
mkdir -p automated_trading/data
```

### 2. é…ç½®è®¾ç½®

```bash
# å¤åˆ¶é…ç½®æ–‡ä»¶
cp config/trading_config.yaml automated_trading/config/

# è®¾ç½®APIå¯†é’¥ï¼ˆ.envæ–‡ä»¶ï¼‰
echo "GATEIO_API_KEY=your_api_key" > .env
echo "GATEIO_API_SECRET=your_api_secret" >> .env
```

### 3. è¿è¡Œç³»ç»Ÿ

```bash
# æµ‹è¯•æ¨¡å¼ï¼ˆenable_trading: falseï¼‰
python automated_trading/main.py

# å®é™…äº¤æ˜“æ¨¡å¼ï¼ˆéœ€è¦å…ˆåœ¨é…ç½®æ–‡ä»¶ä¸­è®¾ç½® enable_trading: trueï¼‰
python automated_trading/main.py
```

## âš ï¸ é‡è¦æé†’

1. **ä»æµ‹è¯•å¼€å§‹**: é¦–å…ˆåœ¨ `enable_trading: false` æ¨¡å¼ä¸‹è¿è¡Œï¼Œè§‚å¯Ÿç­–ç•¥è¡Œä¸º
2. **å°é¢æµ‹è¯•**: åœ¨å®é™…äº¤æ˜“å‰ï¼Œä½¿ç”¨å°é¢èµ„é‡‘è¿›è¡Œæµ‹è¯•
3. **é£é™©æ§åˆ¶**: ä¸¥æ ¼è®¾ç½®é£é™©å‚æ•°ï¼Œä¸è¦æŠ•å…¥æ‰¿å—ä¸èµ·æŸå¤±çš„èµ„é‡‘
4. **ç›‘æ§ç³»ç»Ÿ**: å¯†åˆ‡ç›‘æ§ç³»ç»Ÿè¿è¡ŒçŠ¶æ€å’Œäº¤æ˜“ç»“æœ
5. **ç­–ç•¥ä¼˜åŒ–**: æ ¹æ®å®é™…è¡¨ç°ä¸æ–­è°ƒæ•´ç­–ç•¥å‚æ•°

## ğŸ”§ æ‰©å±•å»ºè®®

1. **æ·»åŠ æ›´å¤šç­–ç•¥**: å®ç°ç½‘æ ¼äº¤æ˜“ã€ç§»åŠ¨å¹³å‡ç­‰ç­–ç•¥
2. **æ”¹è¿›æ•°æ®å­˜å‚¨**: ä½¿ç”¨æ•°æ®åº“å­˜å‚¨å†å²æ•°æ®å’Œäº¤æ˜“è®°å½•
3. **æ·»åŠ Webç•Œé¢**: æ„å»ºWebç•Œé¢è¿›è¡Œç›‘æ§å’Œæ§åˆ¶
4. **å¢å¼ºé£é™©æ§åˆ¶**: æ·»åŠ æ›´å¤šé£é™©æ£€æŸ¥æœºåˆ¶
5. **æ€§èƒ½ä¼˜åŒ–**: ä½¿ç”¨å¼‚æ­¥å¤„ç†æé«˜ç³»ç»Ÿå“åº”é€Ÿåº¦

è¿™ä¸ªç¤ºä¾‹ä¸ºæ‚¨æä¾›äº†ä¸€ä¸ªå¯å·¥ä½œçš„åŸºç¡€æ¡†æ¶ï¼Œæ‚¨å¯ä»¥æ ¹æ®è‡ªå·±çš„éœ€æ±‚è¿›è¡Œæ‰©å±•å’Œä¼˜åŒ–ã€‚ 